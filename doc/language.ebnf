/*
Remove K&R C grammar
Remove va_args and va_list support
Remove switch statement support
Remove initlizer list support
*/

/*
Notice!
The struct and union type is not supported, yet.
*/

translation_unit
	{external_declaration}+

external_declaration
	function_definition | declaration

function_definition
	declaration_specifiers declarator compound_statement

constant_expression
	lit | id

declaration
	declaration_specifiers {init_declarator {',' init_declarator}*}? ';'

declaration_specifiers
	{storage_class_specifier type_specifier type_qualifier}*
    // must have type_specifier 

parameter_type_list
	parameter_list

parameter_list
	parameter_declaration {',' parameter_declaration}*

parameter_declaration
	declaration_specifiers abstract_declarator

init_declarator
	declarator {'=' initializer}?

storage_class_specifier
	{TYPEDEF | EXTERN | STATIC | AUTO | REGISTER}

type_specifier
	{VOID | CHAR | SHORT | INT | LONG | FLOAT | DOUBLE
	| SIGNED | UNSIGNED | struct_or_union_specifier
	| enum_specifier | TYPE_NAME}

struct_or_union_specifier
	{STRUCT | UNION} {
                       {IDENTIFIER | '{' struct_declaration_list '}'} 
                     | {IDENTIFIER '{' struct_declaration_list '}'}
                     }

type_qualifier
	CONST | VOLATILE

declarator
	{pointer}? direct_declarator

direct_declarator
	{IDENTIFIER | '(' declarator ')'} 
    {
            '[' {constant_expression}? ']' 
          | '(' {parameter_type_list}? ')'
    }*

pointer
	'*' {type_qualifier}* {pointer}?

abstract_declarator
	{pointer}* direct_abstract_declarator

direct_abstract_declarator
	  {IDENTIFIER}?
	| '(' abstract_declarator ')'
	| '[' ']'
	| '[' constant_expression ']'
	| direct_abstract_declarator '[' ']'
	| direct_abstract_declarator '[' constant_expression ']'
	| '(' ')'
	| '(' parameter_type_list ')'
	| direct_abstract_declarator '(' ')'
	| direct_abstract_declarator '(' parameter_type_list ')'

struct_declaration_list
	{struct_declaration}+

struct_declaration
	specifier_qualifier_list struct_declarator_list ';'

specifier_qualifier_list
	{type_specifier | type_qualifier}*

struct_declarator_list
	declarator {',' declarator}*

enum_specifier
	ENUM '{' enumerator_list '}'
	| ENUM IDENTIFIER '{' enumerator_list '}'
	| ENUM IDENTIFIER

enumerator_list
	enumerator {',' enumerator}*

enumerator
	IDENTIFIER {'=' constant_expression}

compound_statement
	'{' {declaration_list | statement_list}* '}'

declaration_list
	{declaration}+

statement_list
	{statement}+

statement
	{ compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	}

unary_expression
	  postfix_expression
	| INC_OP unary_expression
	| DEC_OP unary_expression
	| unary_operator cast_expression
	| SIZEOF unary_expression
	| SIZEOF '(' type_name ')'

unary_operator
	  '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'

cast_expression
	  unary_expression
	| '(' type_name ')' cast_expression

type_name
	specifier_qualifier_list {abstract_declarator}?

cast_expression
	  unary_expression
	| '(' type_name ')' cast_expression

primary_expression
	  IDENTIFIER
	| CONSTANT
	| STRING_LITERAL
	| '(' expression ')'

postfix_expression
	  primary_expression
	| postfix_expression '[' expression ']'
	| postfix_expression '(' ')'
	| postfix_expression '(' argument_expression_list ')'
	| postfix_expression '.' IDENTIFIER
	| postfix_expression PTR_OP IDENTIFIER
	| postfix_expression INC_OP
	| postfix_expression DEC_OP

argument_expression_list
	assignment_expression {',' assignment_expression}*

multiplicative_expression
	cast_expression { {'*' | '/' | '%' } cast_expression }*

additive_expression
	multiplicative_expression {('+' | '-') multiplicative_expression}*

shift_expression
	additive_expression {LEFT_OP | RIGHT_OP} additive_expression

relational_expression
	shift_expression {('<' | '>' | LE_OP | GE_OP) shift_expression}*

equality_expression
	relational_expression {EQ_OP | NE_OP relational_expression}*

and_expression
	equality_expression { '&' equality_expression }*

exclusive_or_expression
	and_expression { '^' and_expression }*

inclusive_or_expression
	exclusive_or_expression { '|' exclusive_or_expression }*

logical_and_expression
	inclusive_or_expression {AND_OP inclusive_or_expression}*

logical_or_expression
	logical_and_expression {OR_OP logical_and_expression}*

conditional_expression
	logical_or_expression {'?' expression ':' conditional_expression}?

assignment_expression
	{ conditional_expression
	| unary_expression assignment_operator assignment_expression
	}

assignment_operator
	{'=' | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN
	| SUB_ASSIGN | LEFT_ASSIGN | RIGHT_ASSIGN | AND_ASSIGN
	| XOR_ASSIGN | OR_ASSIGN
    }

expression
	assignment_expression {',' assignment_expression}*

expression_statement
	{expression}? ';'

jump_statement
	{ CONTINUE ';'
	| BREAK ';'
	| RETURN {expression}? ';'
	}

selection_statement
	IF '(' expression ')' statement {ELSE statement}?

iteration_statement
	{ WHILE '(' expression ')' statement
	| DO statement WHILE '(' expression ')' ';'
	| FOR '(' expression_statement expression_statement expression ')' statement
	}

initializer
	{assignment_expression}